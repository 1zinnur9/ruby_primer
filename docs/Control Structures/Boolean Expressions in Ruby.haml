title - Boolean Expressions in Ruby

.section :introduction_to_ruby_expressions, "Beginner's Guide to Expressions in Ruby", 163
  %p
    Ruby uses the <code>==</code> operator for comparing two objects.
    The other usual operators like greater than, less than, greater than or equal to etc. are supported.
    Let us take a look at some sample boolean expressions:

  %p
    Try an expression to see if the <code>name</code> is <code>"Yoshi"</code>.
    !enchant
      exercise!
      short_name :expression_exercise_simple_equals_to

      code_wrapper <<-DATA
        def user_code(name)
          <%= user_code %>
        end
      DATA

      solution <<-DATA
name == "Yoshi"
      DATA

      specs <<-DATA
        it "when given a name 'Yoshi', it should give true" do
          puts user_code.inspect

          user_code("Yoshi").should eq true
        end
        it "when given a name 'Jill', it should give false" do
          puts user_code.inspect

          user_code("Jill").should eq false
        end
        it "when given a name 324, it should give false" do
          puts user_code.inspect

          user_code(324).should eq false
        end
      DATA
    !release

    If Yoshi's <code>age</code> is less than or equal to <code>35</code>.

    !enchant
      exercise!
      short_name :expression_exercise_simple_less_equals_to

      code_wrapper <<-DATA
        def user_code(age)
          <%= user_code %>
        end
      DATA

      solution <<-DATA
age <= 35
      DATA

      specs <<-DATA
        it "when given an age 50, it should give false" do
          user_code(30).should eq true
        end
        it "when given an age 30, it should give true" do
          user_code(60).should eq false
        end
      DATA
    !release

  %p
    Boolean expressions like the above always return either the <code>true</code> or <code>false</code>
    objects.

  %h3 Combining Expressions using the <code>and</code> and <code>or</code> operators
  %p Let us start with the examples:
  %p
    %code age >= 23 and name == 'Bob'
    %br
    %code age >= 23 and name != 'Bob'
    %br
    %br

    Go ahead and write an expression using the above examples to see if the <code>age</code> is greater than or equal to <code>23</code> and the name is either <code>Bob</code> or <code>Jill</code>.
    !enchant
      exercise!
      short_name :expression_exercise_combining_expressions

      code_wrapper <<-DATA
        def user_code(age, name)
          <%= user_code %>
        end
      DATA

      solution <<-DATA
age >= 23 and (name == 'Bob' or name == 'Jill')
      DATA

      specs <<-DATA
        it "when given an age 23 and name 'Bob', it should give true" do
          user_code(23, "Bob").should eq true
        end
        it "when given an age 25 and name 'Jill', it should give true" do
          user_code(25, "Jill").should eq true
        end
        it "when given an age 11 and name 'Bob', it should give false" do
          user_code(11, "Bob").should eq false
        end
        it "when given an age 4 and name 'Jill', it should give false" do
          user_code(4, "Jill").should eq false
        end
      DATA
    !release

  %p
    Just like the order of operations in mathematical expressions (PEMDAS anybody?),
    Ruby also has a set of laws governing the precedence of its various operators. However
    at this point you need not bother much about it. Just make sure to use parantheses generously
    so that the order of operation is unambiguous to Ruby as well as for someone reading your code.

  %h3 Negating expressions
  %p
    Ruby lets you negate expressions using the <code>not</code> operator as well as the <code>!=</code> operator.
    Here's an example that uses the <code>!</code> operator::

    !enchant
      example!
      short_name :expression_exercise_simple_not_equals_to

      starting_code <<-DATA
Time.now.month != 4
      DATA

      code_wrapper <<-DATA
        def user_code
          <%= user_code %>
        end
      DATA

      specs <<-DATA
       puts user_code
      DATA
    !release

    Now try to convert the same example to use the <code>not</code> operator.

    !enchant
      exercise!
      short_name :expression_exercise_simple_not_equals_to_2

      code_wrapper <<-DATA
        def user_code
          <%= user_code %>
        end
      DATA

      solution <<-DATA
not (Time.now.month != 4)
      DATA

      specs <<-DATA
        it "should give true, when Time.now.month is not 4" do
          user_code.should be Time.now.month.eq(4)
        end

        it "should give false, when Time.now.month is 4" do
          user_code.should be Time.now.month.eq(4)
        end
      DATA
    !release

  %p
    It is a good practice to use the <code>not</code> operator around the enclosed
    condition when you need to negate a large expression. Take a look at this slightly
    larger expression:
  %p
    <code>(user.sun_sign != 'gemini' and (not user.birth_time.hour.between? 4, 12))</code>
  %p
    Even though this will work fine, from a code readability perspective, it is better to negate everything
    using a single enclosed <code>not</code>. Like:
  %p
    <code>not (user.sun_sign == 'gemini' or user.birth_time.hour.between? 4, 12)</code>

  %h3 The exercise!
  %p
    Let us say you are trying to recruit team-members for your new startup! Given a <code>candidate</code>,
    you need an expression that will tell you whether they fit into certain types.
    This is how a <code>candidate</code> object would look:
  %p
    %pre{:style => 'font-size: 12px;'}
      candidate.years_of_experience = 4
      candidate.github_points = 293
      candidate.languages_worked_with = ['C', 'Ruby', 'Python', 'Clojure']
      candidate.applied_recently? = false
      candidate.age = 26

  %p
    <b>First Task</b>: Tell me whether a given candidate is a Ruby programmer who has not applied to us recently. For this exercise
    all you need are the <code>candidate.languages_worked_with</code> and <code>candidate.applied_recently?</code> methods.

    !enchant 3271
      exercise!
      requires ['ostruct']
      short_name :expression_exercise_simple_not
      starting_code <<-DATA
        is_a_ruby_programmer = # Fill in the expression here

      DATA
      hint <<-DATA
        Tip 1. Use parantheses generously. If you start your expression with a 'not' operator, wrap the whole expression inside parantheses. <br/>
        Tip 2. languages_worked_with is an Array. How do you check whether an element exists in an Array? Might want to refer to the Ruby Collections chapter for inspiration!
      DATA
      solution <<-DATA
is_a_ruby_programmer = (candidate.languages_worked_with.include? 'Ruby') and
                       (not candidate.applied_recently?)

      DATA
      code_wrapper <<-DATA
        def user_code_input
          <<-USER_INPUT
            <%= user_code %>
          USER_INPUT
        end
      DATA
      specs <<-DATA
        it "classifies a ruby programmer correctly" do
          candidate = OpenStruct.new
          candidate.languages_worked_with = ['Scala', 'Ruby', 'Java']
          def candidate.applied_recently?
            false
          end
          eval(user_code_input).should be
        end
        it "programmers who do not list Ruby among languages that they've worked with are not considered Ruby programmers" do
          candidate = OpenStruct.new
          candidate.languages_worked_with = ['C++', 'Haskell']
          def candidate.applied_recently?
            false
          end
          eval(user_code_input).should_not be
        end
        it "a ruby programmer who has applied recently is not considered" do
          candidate = OpenStruct.new
          candidate.languages_worked_with = ['Ruby', 'Haskell']
          def candidate.applied_recently?
            true
          end
          eval(user_code_input).should_not be
        end
      DATA
    !release

  %p
    Awesome! Now that you've learned how to write boolean expressions in Ruby, let
    us see how we can use them to decide the flow of our application in the
    next lesson.
