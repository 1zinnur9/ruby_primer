.section :empty_arrays, "Empty arrays", 1
  %p
    Let's create an empty array. It's easy. Just do <code>`[]`</code>.

  %p
    See the result? It's pretty obvious that's an empty array. Well, `[]` is actually a shortform of <code>Array.new</code> which is rarely used. Try it


   !enchant 5
      exercise!
      requires ['ostruct']
      short_name :expression_exercise_simple_not
      starting_code <<-DATA
        is_a_ruby_programmer = # Fill in the expression here
        
      DATA
      hint <<-DATA
        Tip 1. Use parantheses generously. If you start your expression with a 'not' operator, wrap the whole expression inside parantheses. <br/>
        Tip 2. languages_worked_with is an Array. How do you check whether an element exists in an Array? Might want to refer to the Ruby Collections chapter for inspiration!
      DATA
      solution <<-DATA
is_a_ruby_programmer = (candidate.languages_worked_with.include? 'Ruby') and 
                       (not candidate.applied_recently?)

      DATA
      code_wrapper <<-DATA
        def user_code_input
          <<-USER_INPUT
            <%= user_code %>
          USER_INPUT
        end
      DATA
      specs <<-DATA
        it "classifies a ruby programmer correctly" do
          candidate = OpenStruct.new
          candidate.languages_worked_with = ['Scala', 'Ruby', 'Java']
          def candidate.applied_recently? 
            false
          end
          eval(user_code_input).should be
        end
6:02
it "programmers who do not list Ruby among languages that they've worked with are not considered Ruby programmers" do
          candidate = OpenStruct.new
          candidate.languages_worked_with = ['C++', 'Haskell']
          def candidate.applied_recently?
            false
          end
          eval(user_code_input).should_not be
        end        
        it "a ruby programmer who has applied recently is not considered" do
          candidate = OpenStruct.new
          candidate.languages_worked_with = ['Ruby', 'Haskell']
          def candidate.applied_recently? 
            true
          end
          eval(user_code_input).should_not be        
        end
      DATA
   !release

  %p
    As you can see - identical results.
    

.section :growing, "Growing arrays", 7
  <span class="tweetable" data-tweet="In ruby any objects can be added to the array, not just strings.">In Ruby, any object of any type can be added to an array, not just numbers.</span> How about appending the word 'woot' to an array? Try using `<<` - that's the 'append' function - to add it to the array below.


   !enchant 9
      short_name :append
      exercise!
      starting_code <<-DATA
              "[1, 2, 3, 4, 5]"
      DATA

      code_wrapper <<-DATA
         def user_code
           <%= user_code %>
         end
      DATA

      specs <<-DATA
         it "should append the string" do
           user_code.should eq([1,2,3,4,5,'woot'])
           
         end
      DATA

   !release


.section :transforming, "Transforming arrays", 11
  Now on to more interesting things, but with a little tip from me first. Try running this:


   !enchant 13
      short_name :map
      exercise!
      starting_code <<-DATA
             "[1, 2, 3, 4, 5].map { |i| i + 1 }"
      DATA

      code_wrapper <<-DATA
         def user_code
           <%= user_code %>
         end
      DATA

      specs <<-DATA
         user_code
      DATA

   !release

  You'll notice that the output, `[2, 3, 4, 5, 6]` is the result of applying the code inside the curly brace to every single element in the array. The result is an entirely new array containing the results.

  In Ruby, the method `map` is used to transform the contents an array according to a specified set of rules defined in code.

  Go on, you try it. Multiply every element in the array below by 3 to get `[3, 6, 9]`.


   !enchant 15
      short_name :multiply_everything
      exercise!
      starting_code <<-DATA
              "[1, 2, 3, 4, 5].map { |i| i + 1 }"
      DATA

      code_wrapper <<-DATA
         def user_code
           <%= user_code %>
         end
      DATA

      specs <<-DATA
         user_code
      DATA

   !release
